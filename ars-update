#!/usr/bin/perl -w
#

# our $VERSION = "__VERSION__";

use strict;
use Scriptalicious qw(1.12);
#use YAML qw(LoadFile DumpFile Dump);
use Storable qw(nstore retrieve);
use File::Find qw(find);
use Set::Object 1.15, qw(set);
use List::Util qw(max);
use Digest::MD5;
use Digest::SHA1;
BEGIN{
  eval {
    require Digest::SHA;
  }
}
use Date::Manip qw(UnixDate);
use IO::Handle;
use YAML::Syck qw(Dump);
use Cwd;
use Fcntl qw(:mode);

my @z = qw(gz bz2);
my %z_progs = (gz => [qw(gzip -9)],
	       bz2 => [qw(bzip2)] );

# hmm.  This should really be configable.  FIXME.
my %suites = (qw(woody oldstable
		 sarge stable
		 sid   unstable
		));

my $force_regen;
my $force_rescan;
my $path;

# these are actually per-repository, but nobody uses them anyway.
# perhaps what we could do is actually read them in from the old
# versions on-disk, so that changes persist.
my $def_origin = "ars-unconfigured";
my $def_label = "Unconfigured ARS";
my $def_desc = "An unconfigured apt-repository-simple";
my $origin;
my $label;
my $desc;
my $no_sign;
my $clean_old;
my $times_not_versions;
my $signing_key;
my $keyring;
my $sec_keyring;
my $no_gpg_agent;
my $perms;
my @gpg_options;

# first, configure just the path..
getopt_lenient getconf ( "path|p=s" => \$path );

our @getopt_options =
	( "force-regen|f" => \$force_regen,
	  "force-rescan|F" => \$force_rescan,
	  "origin|o=s" => \$origin,
	  "label|l=s" => \$label,
	  "desc|D=s" => \$desc,
	  "clean|c" => \$clean_old,
	  "newer|n" => \$times_not_versions,
	  "perms=s" => \$perms,
	  "shared" => sub { $perms = "2775" },
	  "no-sign|S" => \$no_sign,
	  "signing-key|k=s" => \$signing_key,
	  "keyring|K=s" => \$keyring,
	  "secret-keyring|secring=s" => \$sec_keyring,
	  "gpg-option|g=s\@" => \@gpg_options,
	  "no-agent" => \$no_gpg_agent,
	 );

if ( !$no_sign and !$no_gpg_agent and !in_path("gpg-agent") ) {
	moan "no 'gpg-agent'; assuming --no-agent";
	$no_gpg_agent = 1;
}

# get the rest of the options from system default/user config files
getconf @getopt_options;

# allow repository-specific config files in etc/ars.conf
$path ||= ".";
eval { getconf_f "$path/etc/ars.conf", @getopt_options };

# and command-line overrides them all
getopt @getopt_options;

if ($perms) {
	oct($perms) or barf "bad octal value: $perms";
	$perms = oct($perms);
	# apply umask to all files written via umask
	umask( 0777 ^ $perms & 0777 );
}

if ( $path ) {
    chdir($path) or barf "failed to change to $path; $!";
}

$path = cwd;

unless ( $no_gpg_agent or $ENV{GPG_AGENT_INFO} ) {
    # try to find a running agent
    for my $path ( </tmp/gpg-*/S.*> ) {
	if ( -S $path ) {
	    my $pid;
	    eval {
		local $SIG{ALRM} = sub { die "alarm\n" };
		alarm 5;
		$pid = `fuser $path 2>/dev/null`;
		alarm 0;
	    };
	    chomp($pid);
	    if ( $pid ) {
		whisper "using GPG agent PID $pid";
		$ENV{GPG_AGENT_INFO}="$path:$pid:1";
		last;
	    }
	}
    }
    if ( !$ENV{GPG_AGENT_INFO} ) {
	say "Starting the GPG agent";
	my @vars = `gpg-agent -s --daemon 2>/dev/null`;
	if ( $? ) {
	    moan "no GPG agent found - disabling GPG agent";
	    $no_gpg_agent = 1;
	} else {
	    for ( @vars ) {
		chomp;
		my ($var, $val) = split "=", $_, 2;
		$ENV{$var} = $val;
	    }
	}
    }
}

if ( $keyring and !$sec_keyring ) {
  ($sec_keyring = $keyring) =~ s{(p)ubring}{secring};
  undef($sec_keyring) unless $1;
}

push @gpg_options,
    ( ($no_gpg_agent? () : ("--use-agent")),
      ($signing_key ? ("--default-key", $signing_key) : ()),
      ($keyring ? ("--keyring", $keyring) : ()),
      ($sec_keyring ? ("--secret-keyring", $sec_keyring) : ()),
    );

my @dirs = <pool/*>;

my @indep_dirs;
my %dists;
my %dist_dirs;

my $superceded = set();
my $all_arches = set();

for my $dir (@dirs) {

    next unless -d $dir;

    say "processing $dir";
    my ($pool) = ($dir =~ m{.*/(.*)});

    if (my ($dist, $arch) = ($pool =~ m{(.*)-(.*)})) {
	if ($arch eq "all") {
	    push @{ $dists{$dist}||=[] }, $dir
	} else {
	    push @{ $dist_dirs{$dist}{$arch} ||= [] }, $dir;
	    $all_arches->insert($arch);
	}
    } elsif ( $pool =~ m{^(all|indep|any)$} ) {
	push @indep_dirs, $dir;
    } else {
	whisper "ignoring directory $dir";
	next;
    }

    my $statefile = "$dir/packages.pm3";
    my %pkgs;

    my $dirty = 0;
    if ( -e $statefile) {
	%pkgs = %{ retrieve $statefile };
	while (my ($k, $v) = each %pkgs) {
	    # spot a renamed pool and fix the data up.
	    my ($old_pool) = $v->{filename} =~ m{^pool/([^/]*)};
	    if ( $old_pool ne $pool ) {
		#whisper "detected pool change in $v->{filename}";
		$v->{filename} =~
		    s{^pool/\Q$old_pool\E}{pool/$pool};
		$dirty = 1;
	    }

 	    unless ( -e $v->{filename} ) {
	        delete $pkgs{$k};
		$dirty = 1;
	    }
	}
    }

    find(sub {
	return if m{^(\.\.?|.*\.(yml|pm3|tar.gz|changes|diff.gz|groups|new))$};
	(my $rel_filename = $File::Find::name) =~ s{^\./*}{};
	if ( -f ) {
	    my ($pkg, $vers, $arch, $is_src)
              = m{^([^_]*)_([^_]*)(?:_([^_]*)\.deb|\.(dsc))$}
	        or do {
                  moan "file $rel_filename doesn't match debian form!";
                  return;
                };
            if ( $is_src ) {
              $arch = "source";
            }
	    if ($pkgs{$pkg}) {
		# ignore epoch for now
		if ( $rel_filename eq $pkgs{$pkg}{filename} ) {

		    # force a rescan if the timestamp changes
		    if ( (stat _)[9] != $pkgs{$pkg}{mtime} ) {
			#whisper "rescanning $pkg (mtime changed)";
			delete $pkgs{$pkg};
		    }
		}
		elsif ( ( $times_not_versions
			  ? ( $pkgs{$pkg}{mtime} < ((stat _)[9]) )
			  : ( debvers_cmp($pkgs{$pkg}{version}, $vers) < 0
			      or ( $pkgs{$pkg}{version} eq $vers
				   and $pkgs{$pkg}{mtime} != ((stat _)[9]))
			    ) )
			or ( ! -e "$path/$pkgs{$pkg}{filename}" )
		      ) {
		    whisper "superceding $pkgs{$pkg}{filename} with $vers";
		    $superceded->insert($pkgs{$pkg}{filename});
		    delete $pkgs{$pkg};
		} else {
        	    whisper "$rel_filename is already superceded by "
			."$pkgs{$pkg}{filename}";
		    $superceded->insert($rel_filename);
		}
	    }
	    if (!$pkgs{$pkg} or $force_rescan or
                (!$pkgs{$pkg}{digests} && ($force_regen=1))) {
		$dirty++;
		mutter "adding $pkg from $rel_filename";
                my $digests;
                my $filename = $_;
                {
                  open FILE, "<$filename"
                    or die "failed to open $filename for reading; $!";
                  binmode FILE;
                  local($/)=\((stat FILE)[11]||4096);
                  my $digest = Digest::All->new();
                  while ( <FILE> ) {
                    $digest->add($_);
                  }
                  stat FILE;
                  close FILE;
                  $digests = $digest->hexdigests;
                }
		my @groups;
		#stat $rel_filename;
		my $mtime = ((stat _)[9]);
		my $size = ((stat _)[7]);
		if ( -f "$filename.groups" ) {
		    @groups = map { chomp; $_ } `cat $filename.groups`;
		    if ( !@groups ) {
			unlink "$filename.groups";
		    }
		}
                my $info = grok_dpkg_info($filename);
                my %source_pieces;
                if ( $is_src ) {
                  # verify the source files exist and have correct checksum...
                  my $info_h = { @$info };
                  my %others;
                  for my $hash ( qw(SHA1 SHA256 MD5) ) {
                    my $heading = ($hash eq "MD5" ? "Files"
                                   : "Checksums-".ucfirst(lc($hash)));
                    next unless $info_h->{$heading};
                    my @lines = split "\n", $info_h->{$heading};
                    for my $line ( @lines ) {
                      my ($hexdigest, $size, $piece_filename)
                        = split " ", $line;
                      if ( $hash ne "MD5" ) {
                        $others{$piece_filename}{$hash} = $hexdigest;
                      } else {
                        my $bad;
                        $source_pieces{$piece_filename}++;
                        if ( ! -f $piece_filename ) {
                          moan("$piece_filename not found!");
                          $bad = 1;
                        }
                        elsif ( (-s _) != $size ) {
                          moan("$piece_filename wrong size!");
                          $bad = 1;
                        }
                        elsif ( ! open SRC_PART, "<$piece_filename" ) {
                          moan "failed to open $piece_filename for reading; $!";
                          $bad = 1;
                        }
                        else {
                          binmode SRC_PART;
                          local($/)=\((stat SRC_PART)[11]||4096);
                          my $digest = Digest::All->new();
                          while ( <SRC_PART> ) {
                            $digest->add($_);
                          }
                          close SRC_PART;
                          my $digests = $digest->hexdigests;
                          my $o = $others{$piece_filename};
                          if ( $digests->{MD5} ne $hexdigest ) {
                            moan "MD5 mismatch on $piece_filename";
                            $bad = 1;
                          }
                          elsif ( $o->{SHA1} and $digests->{SHA1} and
                                  $digests->{SHA1} ne $o->{SHA1} ) {
                            moan "SHA1 mismatch on $piece_filename ($o->{SHA1} vs $digests->{SHA1})!  But both files have $hexdigest MD5!  Wow!";
                            $bad = 1;
                          }
                          elsif ( $o->{SHA256} and $digests->{SHA256} and
                                  $digests->{SHA256} ne $o->{SHA256} ) {
                            moan "SHA256 mismatch on $piece_filename!  Holy Cow!  A real SHA1 collision!  Someone call Bruce Schneier!";
                            $bad = 1;
                          }
                        }
                        if ( $bad ) {
                          moan("not indexing $pkg ($dir)");
                          delete $pkgs{$pkg};
                          return;
                        }
                      }
                    }
                  }
                }
		$pkgs{$pkg} =
		    {
		     filename => $rel_filename,
		     version => $vers,
		     mtime => $mtime,
		     size => $size,
                     digests => $digests,
		     info => $info,
		     ($is_src
                      ? (pieces => [sort keys %source_pieces])
                      : (md5sums => get_md5sums($filename))),
		     groups => set(@groups),
		    };
	    }
        };
    }, $dir);

    if ($dirty) {
	unlink("$statefile.new");
        nstore \%pkgs, "$statefile.new";
	rename "$statefile.new", $statefile
		or barf "rename($statefile.new, $statefile) failed; $!";
    }
    mutter("$dir: $dirty package(s) updated");
}


for my $dist ( (set(keys %dists) + set(keys %dist_dirs))->members ) {

    my $Release = "dists/$dist/Release.pm3";
    my $release = eval { retrieve $Release } || [];
    my $dirty;
    my %done_contents;

    my %sums;
    my $files = set();
    my $every_group = set();

    unless ( grep !/^(source|all)/, keys %{ $dist_dirs{$dist} } ) {
	my @arches = $all_arches->members;
	if ( ! @arches ) {
	    chomp(my $DEB_HOST_ARCH =
		  `(dpkg --print-architecture || uname -m) 2>/dev/null`);
	    @arches = $DEB_HOST_ARCH;
	}

	moan "dist '$dist' missing arch-specific dirs; using: @arches";
	$dist_dirs{$dist}{$_}=[] for @arches;
	$all_arches->insert(@arches);
    }

    for my $arch ( $all_arches->members ) {

	# FIXME - write proper Sources files
        my $source = $arch =~ /sources?/;

	my @files = grep { -e }
	    map { "$_/packages.pm3" }
		@{ $dist_dirs{$dist}{$arch}||[] },
                  ($source ? () : ( @{ $dists{$dist} }, @indep_dirs ));

	my @dirs = map { retrieve $_ } @files;
	( -d "dists" ) || _mkdir("dists", $perms);
	( -d "dists/$dist" ) || _mkdir("dists/$dist", $perms);

        unless ( $source ) {
          mutter("preparing Contents files for $dist-$arch");

          my $Contents = "dists/$dist/Contents-$arch.gz";
          unlink("$Contents.new");
          open CONTENTS, "| gzip > $Contents.new";
          $files->insert($Contents);
          print CONTENTS "Install the apt-file package to automatically search this file.
FILE LOCATION\n";
        }

        my %pkgs;
	my $all_groups = set();
        for my $dir (@dirs) {
          while (my ($pkg, $info) = each %$dir) {
            if ($pkgs{$pkg}) {
              moan "package $pkg appears more than once in dirs for $dist-$arch";
            } else {
              $pkgs{$pkg} = $info;
              my @groups = ($info->{groups}||set())->members;
              $all_groups->insert(@groups);
              unless ( $source ) {
                my $md5sums = $info->{md5sums};
                my ($primary_group) = ( (sort @groups), "all");
                for (my $i = 0; $i < $#$md5sums; $i+=2) {
                  print CONTENTS $md5sums->[$i], " ", "$primary_group/$pkg", "\n";
                }
              }
            }
          }
        }
        close CONTENTS unless $source;

	$every_group += $all_groups;

	for my $group ( "all", $all_groups->members ) {

	    my $dir = "dists/$dist/$group/"
              .($source ? "source" : "binary-$arch");

	    ( -e $dir ) || _mkdir($dir, $perms);

	    open RELEASE, ">$dir/Release.new"
		or barf "open($dir/Release.new) failed; $!";

	    my ($conf_origin, $conf_label) = @{{
		map { chomp; split ": ", $_, 2 }
		    grep { m{^\w+: } }
			`cat $dir/Release`
	    }}{qw(Origin Label)}
		if ( -e "$dir/Release" );

	    my $release_data = join "", map { $_, "\n" }
		"Archive: $dist",
     		"Component: $group",
     		"Origin: ${\( $origin || $conf_origin || $def_origin )}",
     		"Label: ${\( $label || $conf_label || $def_label )}",
     		"Architecture: $arch";
	    print RELEASE $release_data;
	    close RELEASE;
	    {
              my $digest = Digest::All->new;
              $digest->add($release_data);
              my $length = length $release_data;
              push @$release, $digest->release_lines("$dir/Release");
	    }

	    my $Packages = "$dir/".($source?"Sources":"Packages");

	    my $max = (max map { ((stat $_)[9]) } @files) ;
	    if ( ($max||0) < ((stat $Packages)[9]||0) and !$force_regen ) {
		mutter "no new packages in $dist-$arch ($group)";
		# we still need to get the sums...
		for my $file ( $Packages, "$Packages.gz", "$Packages.bz2" ) {
		    next unless -f $file;
		    mutter "getting checksums for $file";
		    local($/)=\((stat _)[11]||4096);
		    open FILE, "<$file" or die $!;
		    binmode FILE;
                    my $digest = Digest::All->new();
		    while ( <FILE> ) {
                      $digest->add($_);
		    }
		    close FILE;
		    push @$release, $digest->release_lines($file);
		}
		next;
	    }

	    # for getting back MD5 and SHA1 sums
	    pipe(PARENT_RDR, CHILD_WTR);

            pipe(PACKAGES_RDR, PACKAGES_WTR);
	    if (my $pid = fork()) {
		close PACKAGES_RDR;
		if (my $pid2 = fork()) {
		    close PACKAGES_WTR;
		    close CHILD_WTR;
		    # this process collects SHA1 and MD5 sums and filesizes
		    while (<PARENT_RDR>) {
			push @$release, $_;
		    }
		    close PARENT_RDR;
		} elsif (!defined $pid2) {
		    die "fork failed; $!";
		} else {
		    # this process writes the Packages contents
		    my $n;
                    my $digest = Digest::All->new();
                    unlink("$Packages.new");
		    open REALPACKAGES, ">$Packages.new" or barf("open($Packages.new) failed; $!");
		    for my $pkg (sort keys %pkgs) {
			next unless $group eq "all" or
			    ($pkgs{$pkg}{groups} and
			     $pkgs{$pkg}{groups}->includes($group));
			print PACKAGES_WTR map {
			    defined($_) or warn "bah";
			    $digest->add($_);
			    print REALPACKAGES $_;
			    $_
			} ($n++ ? "\n" : ""), display($pkgs{$pkg}, "pool/$dir");
		    }
		    close REALPACKAGES;
		    #close PACKAGES;
		    print CHILD_WTR $digest->release_lines($Packages);
		    exit(0);
		}
	    } elsif (!defined $pid) {
		die "fork failed; $!";
	    } else {

		# child - sees Packages content on STDIN.
		open STDIN, "<&PACKAGES_RDR";
		close PACKAGES_WTR;
		# This process just does a "tee", but we create
		# md5/sha1 objects for the children to summing the
		# compressed versions
                my $digest = Digest::All->new();
		my %fh;
		for my $z (@z) {
		    if (my $z_pid = open $fh{$z}, "|-") {
			# parent... just continue
		    } elsif (!defined $z_pid) {
			die "fork failed; $!";
		    } else {
			close $_ for values %fh;
			if (my $z_sum_pid = open STDOUT, "|-") {
			    exec(@{$z_progs{$z}}) or exit(1);
			} else {
			    open STDOUT, ">$Packages.$z.new" or barf $!;
			    while (read STDIN, $_, 1024) {
                              $digest->add($_);
                              print $_;
			    }
			    print CHILD_WTR $digest->release_lines("$Packages.$z");
			    exit(0);
			}
		    }
		}
		close CHILD_WTR;
		while (<STDIN>) {
		    #$length += length $_;
		    for my $i (@z) { print { $fh{$i} } $_ };
		}
		exit(0);
	    }
	    # just like that!  :)
	}

	mutter "preparing Release file for $dist";
	unlink("$Release.new");
	nstore $release, "$Release.new";
	rename "$Release.new", $Release
		or barf "rename($Release.new, $Release) failed; $!";
    }

    my ($conf_origin, $conf_label, $conf_desc) = @{{
	map { chomp; split ": ", $_, 2 }
	    grep { m{^\w+: } }
		`cat dists/$dist/Release`
	    }}{qw(Origin Label Description)}
		if ( -e "dists/$dist/Release" );

    open RELEASE, ">dists/$dist/Release.new" or barf "open(>dists/$dist/Release.new) failed; $!";
    print RELEASE "Origin: ${\( $origin || $conf_origin || $def_origin )}
Label: ${\( $label || $conf_label || $def_label )}
Suite: ${\( $suites{$dist} || $dist )}
Codename: $dist
Date: ".UnixDate("now", "%g")."
Architectures: ".join(" ",( grep { $_ !~ /source/ }
			    keys %{ $dist_dirs{$dist} } ))."
Components: all @{[ sort $every_group->members ]}
Description: ${\( $desc || $conf_desc || $def_desc )}
";
    for my $line (@$release) {
	my ($type, $digest, $length, $filename) = split ":", $line;
        next unless $digest;
	chomp($filename);
	$sums{$type}{$filename} = [ $digest, $length ];
	$files->insert($filename)
	    if ( -e "$filename.new" );
    }
    for my $type (qw(MD5Sum SHA1 SHA256)) {
      next unless $sums{$type} and keys %{$sums{$type}};
	print RELEASE "$type:\n";
	for my $filename (sort keys %{ $sums{$type} }) {
	    my ($digest, $length) = @{ $sums{$type}{$filename} };
	    $filename =~ s{dists/$dist/}{};
	    printf RELEASE " %s %16d %s\n", $digest, $length, $filename;
	}
    }
    close RELEASE;
    say "wrote dists/$dist/Release";
    unless ( $no_sign ) {
	unlink("dists/$dist/Release.new.asc");

	run(-in => \*STDIN, -out => \*STDOUT,
	    "gpg", @gpg_options, "-b", "-a", "dists/$dist/Release.new");
	    
	if ( ! -s "dists/$dist/Release.new.asc" ) {
	    moan("gpg sign failed; rc=$?");
	} else {
	    rename("dists/$dist/Release.new.asc", "dists/$dist/Release.gpg.new");
	    $files->insert("dists/$dist/Release.gpg");
	}
    }
    for my $file ($files->members, "dists/$dist/Release") {
	rename("$file.new", $file) or barf("rename($file.new, $file) failed; $!");
    }
}

if ( $clean_old and $superceded->size ) {
    say "deleting superceded files:";
    for ( sort @$superceded ) {
	print "    $_\n";
    }
    unlink(@$superceded);
}

exit 0;

sub display {
    my $info = shift;
    my $dir = shift;
    my $dpkg_info = $info->{info}
      or do {
        say("no dpkg info!  Got:".Dump($info));
      };
    my @rv;
    if ( $info->{filename} =~ m{\.dsc$} ) {
      # need to do something different
      my %info = @$dpkg_info;
      delete $info{Hash};
      my $x = sub {
        push @rv, "$_: ", delete($info{$_}), "\n"
          for grep { exists $info{$_} } @_;
      };
      push @rv, "Package: ", delete $info{Source}, "\n";
      $x->(qw(Binary Version));
      push @rv, "Priority: optional\n";
      push @rv, "Section: optional\n";
      $x->(qw(Maintainer Build-Depends Build-Depends-Indep
              Architecture Standards-Version Format));
      push @rv, "Directory: ", $dir, "\n";
      (my $shortname = $info->{filename}) =~ s{.*/}{};
      for my $hash ( qw(MD5 SHA1 SHA256) ) {
        next unless $info->{digests}{$hash};
        my $heading = ($hash eq "MD5" ? "Files"
                       : "Checksums-".ucfirst(lc($hash)));
        next unless $info{$heading};
        push @rv, $heading, ":\n";
        push @rv, " ", $info->{digests}{$hash}, " ", $info->{size},
          " ", $shortname, "\n";
        push @rv, map { (" ", $_, "\n") } split "\n",
          delete $info{$heading};
      }
      for my $extra ( sort keys %info ) {
        my $data = $info{$extra};
        push @rv, $extra, ":";
        if ( $data =~ /\n/ ) {
          push @rv, "\n";
          push @rv, map { (" ", $_, "\n") } split "\n", $data;
        }
        else {
          push @rv, " ", $data, "\n";
        }
      }
    }
    else {
      for (my $i = 0; ($i * 2)+2 < @$dpkg_info; $i++) {
	push @rv, $dpkg_info->[($i*2)], ": ", $dpkg_info->[($i*2)+1], "\n";
      }

      push @rv, "Filename: ", $info->{filename}, "\n";
      push @rv, "Size: ", $info->{size}, "\n";
      push @rv, "MD5sum: ", $info->{digests}{MD5}, "\n";
      push @rv, "SHA1: ", $info->{digests}{SHA1}, "\n";
      push @rv, "SHA256: ", $info->{digests}{SHA256}, "\n"
        if $info->{digests}{SHA256};

      push @rv, $dpkg_info->[$#$dpkg_info-1], ": ",
	$dpkg_info->[$#$dpkg_info],"\n";
    }

    if ( grep { !defined } @rv ) {
	moan "display for $info->{filename} returns: ";
	say Dump \@rv;
	say "info is:";
	say Dump $info;
    }

    return @rv;
}

sub grok_dpkg_info {
    my $filename = shift;
    my @data;
    if ( $filename =~ m{\.deb$} ) {
      my $data = capture(qw(dpkg -I), $filename);

      scalar($data =~ m{\A.*^ Package: (\S+)\n}msg);
      @data = ( "Package" => $1 );
      while ($data =~ m{\G (\S+): ((?-s:.*(\n  .*)*))\n}sg) {
        my ($what, $value) = ($1, $2);
	$value =~ s{^ }{}mg;
	chomp($value);
	push @data, $what => $value;
      }
    }
    elsif ( $filename =~ m{\.dsc$} ) {
      open DESC, "<$filename" or die $!;
      my $field;
      my %data;
      while ( <DESC> ) {
        if ( m{^(\S+):\s*(.*)} ) {
          $field = $1;
          $data{$field} = $2;
        }
        elsif ( m{^\s+(\S.*)} ) {
          if ( $field ) {
            $data{$field} .= (length($data{$field})? "\n" : ""). "$1";
          }
        }
        else {
          undef($field);
        }
      }
      @data = %data;
    }
    else {
      die;
    }
    return \@data;
}

sub get_md5sums {
    my $filename = shift;
    my @sums;
    if ( $filename =~ m{\.deb$} ) {
      my ($err, @data) = capture_err(qw(dpkg -I), $filename, "md5sums");
      return undef if $err;
      @sums = map { chomp; m/(\S+)\s*(.*)/ && ($2 => $1) } @data;
    }
    elsif ( $filename =~ m{\.dsc$} ) {
      open DESC, "<$filename" or die $!;
      while ( <DESC> ) {
        if ( /Files:/../^\s*$/ ) {
          m{^\s+([a-f0-9]+)\s+\d+\s+(\S.*)} && push(@sums, $2, $1);
        }
      }
    }
    return \@sums;
}

sub split_debver {
    my ($epoch, $version, $revision);
    my $ver = shift;
    if ($ver =~ /:/)
    {
	$ver =~ /^(\d+):(.+)/ or die "bad version number '$ver'";
	$epoch = $1;
	$ver = $2;
    }
    else
    {
	$epoch = 0;
    }
    if ($ver =~ /(.+)-(.+)$/)
    {
	$version = $1;
	$revision = $2;
    }
    else
    {
	$version = $ver;
	$revision = 0;
    }
    return ($epoch, $version, $revision);
}

# cmp_vers

# This function is almost exactly equivalent
# to dpkg's verrevcmp function, including the
# order subroutine which it uses.

sub verrevcmp_order {
	my ($x) = @_;
	##define order(x) ((x) == '~' ? -1 \
	#           : cisdigit((x)) ? 0 \
	#           : !(x) ? 0 \
	#           : cisalpha((x)) ? (x) \
	#           : (x) + 256)
	# This comparison is out of dpkg's order to avoid
	# comparing things to undef and triggering warnings.
	if (not defined $x) {
		return 0;
	}
	elsif ($x eq '~') {
		return -1;
	}
	elsif ($x =~ /^\d$/) {
		return 0;
	}
	elsif ($x =~ /^[A-Z]$/i) {
		return ord($x);
	}
	else {
		return ord($x) + 256;
	}
}

sub cmp_vers($$)
{
     my ($val, $ref) = @_;
     $val = "" if not defined $val;
     $ref = "" if not defined $ref;
     my @val = split //,$val;
     my @ref = split //,$ref;
     my $vc = shift @val;
     my $rc = shift @ref;
     while (defined $vc or defined $rc) {
	  my $first_diff = 0;
	  while ((defined $vc and $vc !~ /^\d$/) or
		 (defined $rc and $rc !~ /^\d$/)) {
	       my $vo = verrevcmp_order($vc);
	       my $ro = verrevcmp_order($rc);
	       # Unlike dpkg's verrevcmp, we only return 1 or -1 here.
	       return (($vo - $ro > 0) ? 1 : -1) if $vo != $ro;
	       $vc = shift @val; $rc = shift @ref;
	  }
	  while (defined $vc and $vc eq '0') {
	       $vc = shift @val;
	  }
	  while (defined $rc and $rc eq '0') {
	       $rc = shift @ref;
	  }
	  while (defined $vc and $vc =~ /^\d$/ and
		 defined $rc and $rc =~ /^\d$/) {
	       $first_diff = ord($vc) - ord($rc) if !$first_diff;
	       $vc = shift @val; $rc = shift @ref;
	  }
	  return 1 if defined $vc and $vc =~ /^\d$/;
	  return -1 if defined $rc and $rc =~ /^\d$/;
	  return $first_diff if $first_diff;
     }
     return 0;
}

sub debvers_cmp {
    my ($a_ep, $a_v, $a_post) = split_debver(shift);
    my ($b_ep, $b_v, $b_post) = split_debver(shift);
    cmp_vers($a_ep, $b_ep)
      or
    cmp_vers($a_v, $b_v)
      or
    cmp_vers($a_post, $b_post)
}

sub _mkdir {
    my $dir = shift;
    my $perms = shift;
    my ($dn) = ($dir =~ m{(.*)/[^/]*/?$});
    if ( $dn and ! -d $dn ) {
    	_mkdir($dn, $perms);
    }
    if ( ! -d $dir ) {
        mkdir($dir) or barf "mkdir($dir) failed; $!";
	stat $dir;
    }
    if ($perms) {
    	my $mode = (stat _)[2];
	if ( ($mode & 07777) != $perms ) {
	    chmod($perms, $dir) or barf "chmod($perms, $dir) failed; $!";
    	}
    }
}

sub in_path {
	my $binary = shift;
	for (split ":", $ENV{PATH}) {
		if ( -x "$_/$binary" ) {
			return 1;
		}
	}
	0;
}

package Digest::All;
sub new {
  my $sha256 = eval { Digest::SHA->new(256) };
  return bless { MD5 => Digest::MD5->new(),
                 SHA1 => Digest::SHA1->new(),
                 ($sha256 ? (SHA256 => $sha256) : () ),
                 length => 0,
         }, shift;
}

sub add {
  my $digest = shift;
  my $block = shift;
  for my $eater ( values %$digest ) {
    $eater->add($block) if ref $eater;
  }
  $digest->{length} += length $block;
}

sub hexdigests {
  my $digest = shift;
  my %rv;
  while ( my ($alg, $eater) = each %$digest ) {
    $rv{$alg} = $eater->hexdigest if ref $eater;
  }
  \%rv;
}

sub release_lines {
  my $digest = shift;
  my $filename = shift;
  my $hexdigests = $digest->hexdigests;
  $hexdigests->{MD5Sum} = delete $hexdigests->{MD5};
  my @rv;
  for ( qw(MD5Sum SHA1 SHA256) ) {
    push @rv, join(":", $_ => $hexdigests->{$_} =>
                   $digest->{length} => $filename)."\n"
                     if $hexdigests->{$_};
  }
  wantarray ? @rv : \@rv;
}

__END__

=head1 NAME

ars-update - update Packages files in simple apt repositories

=head1 SYNOPSIS

 ars-update [options]

=head1 DESCRIPTION

This script scans a pool of directories (in F<pool/>), which are
assumed to be in the form I<dist>-I<arch> (where I<arch> may be
C<all>, or a real arch like C<i386> or C<amd64>).

This script works a bit like C<dpkg-scanpackages>, its principle
difference being that it caches information between runs.  This makes
it orders of magnitude faster for many common cases.

=head1 COMMAND LINE OPTIONS

=over

=item B<-f, --force-regen>

Force all Packages lists to be regenerated, not just the ones that
changed.

=item B<-F, --force-rescan>

Force all packages to be checksummed and scanned, not just the ones
whose filestamps changed.

=item B<-p, --path=PATH>

Specify a directory other than the working directory that the APT
repository is rooted.

=item B<-o, --origin=ORIGIN>

Specify the APT Origin.  Used to pin packages with
/etc/apt/preferences, etc.

=item B<-l, --label=LABEL>

Specify the APT Label.  Similar use to Origin.

=item B<-D, --desc="Description">

An optional description of the archive.

=item B<-S, --no-sign>

Don't try to generate F<.asc> files for the F<Packages> and F<Release>
files.  These files allow packages to be installed without warning the
user about them being unsigned - but only if the user also has the key
used for signing in their APT keyring.  See L<apt-key>.

=item B<-k, --signing-key=ID>

Specify the PGP key used for signing.  Note that this is relative to
the ARS root.

=item B<-K, --keyring=FILE>

Specify the keyring in which to find the public PGP key used for
verifying the signing key is valid.

=item B<--secring, --secret-keyring=FILE>

Specify the secret keyring, in which to find the private PGP key used
for signing.  This default to the same as the keyring, but with
C<pubring> replaced with C<secring>.

=item B<-g, --gpg-option=X>

Aux. method for feeding gpg commandline options

=item B<--no-agent>

Suppress the C<--use-agent> option to GPG.

=item B<-c, --clean>

Delete all packages which have newer packages in the same pool dir.

=item B<-n, --newer>

When deciding if a package is older or newer than another one with the
same name, use the timestamp, not the version number.

=item B<-h, --help>

Display a program usage screen and exit.

=item B<-V, --version>

Display program version and exit.

=item B<-v, --verbose>

Verbose command execution, displaying things like the
commands run, their output, etc.

=item B<-q, --quiet>

Suppress all normal program output; only display errors and
warnings.

=item B<-d, --debug>

Display output to help someone debug this script, not the
process going on.

=back

=head1 CONFIGURATION FILES

You can configure this program by placing a YAML file in any of the
following locations:

=over

=item F<$HOME/.ars-updaterc>

=item F</etc/perl/ars-update.conf>

=item F</etc/ars-update.conf>

Defaults places that Scriptalicious will search for configuration.

=item F<path/etc/ars-update.conf>

In-repository configuration.

=back

The format of this file should be option: value; eg,

  origin: mycompany.com
  label: My Company's Stuff
  shared: 1
  signing-key: 0xCAFEBABE
  keyring: keys/pubring.gpg

=head1 SEE ALSO

L<dpkg-scanpackages>, L<dpkg-deb>, L<apt>

=head1 AUTHOR AND LICENSE

Most development by Sam Vilain, <samv@cpan.org>.  Sponsored by
Catalyst IT Ltd, L<http://www.catalyst.net.nz/>.  Copyright 2006-2008,
Catalyst IT.

A couple of functions were lifted from Dpkg::Version, potentially any
of these copyright notices apply:

Copyright Colin Watson <cjwatson@debian.org>
Copyright Ian Jackson <iwj@debian.org>
Copyright 2007 by Don Armstrong <don@donarmstrong.com>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see L<http://www.gnu.org/licenses/>.

=cut
